---
title: "Main notebook"
output: pdf_document
date: '2023-02-01'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Acknowledgements

The data and a large portion of data preprocessing is provided by Jane Reid. The re-implementation into INLA is also largely based on the work from Stefanie Muff.

# Data loading

```{r data loading}
library(MCMCglmm)
library(MASS)
library(nadiv)
library(bdsmatrix)
library(INLA)
library(QGglmm)
# library(SMisc)
library(ggplot2)
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
if (!require("GeneticsPed", quietly = TRUE))
    BiocManager::install("GeneticsPed")

library("GeneticsPed") 
library("MCMCglmm")


qg.data.gg.inds <- read.table("../data/qg.data.gg.inds.steffi.txt", header=T)
d.ped <- ped.prune.inds <- read.table("../data/ped.prune.inds.steffi.txt", header=T)
d.Q <-  read.table("../data/Q.data.steffi.txt", header=T)

qg.data.gg.inds$natalyr.id <- qg.data.gg.inds$natalyr.no

```

Scaling continuous variances can be more stable: (I think?)

```{r}
qg.data.gg.inds$f.coef.sc <- scale(qg.data.gg.inds$f.coef,scale=FALSE)
qg.data.gg.inds$g1.sc <- scale(qg.data.gg.inds$g1,scale=FALSE)
qg.data.gg.inds$natalyr.no.sc <- scale(qg.data.gg.inds$natalyr.no,scale=FALSE)
qg.data.gg.inds$brood.date.sc <- scale(qg.data.gg.inds$brood.date,scale=FALSE)
```

The sex covariate is either `1` or `2`, so we binarize this covariate:

```{r}
qg.data.gg.inds$sex <- qg.data.gg.inds$sex.use.x1 - 1 
```

## Deriving *A*

In order to derive the A matrix, we need to work a bit

```{r}
d.ped <- nadiv::prepPed(d.ped)
```

In particular, for INLA we need ids that run from 1 to the number of individuals

```{r}
d.ped$id <- 1:(nrow(d.ped))
```

Need a map file to keep track of the ids

```{r}
d.map <- d.ped[,c("ninecode","id")]
d.map$g1 <- d.Q[match(d.map$ninecode,d.Q$ninecode),"g1"]
d.map$foc0 <- d.Q[match(d.map$ninecode,d.Q$ninecode),"foc0"]
```

Give mother and father the id

```{r}
d.ped$mother.id <- d.map[match(d.ped$gendam, d.map$ninecode),"id"]
d.ped$father.id <- d.map[match(d.ped$gensire, d.map$ninecode),"id"]
```

Make the inverse A matrix using the `nadiv` package:

```{r}
Cmatrix <- nadiv::makeAinv(d.ped[,c("id","mother.id","father.id")])$Ainv
```

Store the id twice: Once for the breeding value, and once for the independent residuals u with variance 1 (the latter are not going to be included in the end, but we checked what happened when they were there)

```{r}
qg.data.gg.inds$id <- d.map[match(qg.data.gg.inds$ninecode, d.map$ninecode), "id"]
qg.data.gg.inds$u <- 1:nrow(qg.data.gg.inds)
```

# INLA

The general INLA formula is provided below, where `f()` encode the random effect:

```{r}

formula.inla.scaled = surv.ind.to.ad ~ f.coef.sc + g1.sc + natalyr.no.sc + brood.date.sc + sex +
  f(nestrec, model="iid",hyper=list(
    prec=list(initial=log(1/0.05), prior="pc.prec",param=c(1,0.05)) # PC priors
  )) +
  f(natalyr.id, model="iid",hyper=list(
    prec=list(initial=log(1/0.25), prior="pc.prec",param=c(1,0.05)) # PC priors
  )) +
  f(id,model="generic0", # Here we need to specify the covariance matrix 
    Cmatrix=Cmatrix,     #    via the inverse (Cmatrix)
    constr = F, # Doesn't really matter
    hyper=list(
      prec=list(initial=log(1/10), prior="pc.prec",param=c(1,0.05)) # PC priors
     ))  + # this last part is only needed if the u~N(0,1) residuals are included
f(u, model="iid",
  constr=TRUE,
  hyper=list(
    prec=list(initial=log(1), fixed=TRUE) # Fixed variance to 1
  )) # This last component adds the independent residuals with variance 1;
```

Now we call INLA models, this is the slowest part:

```{r}

fit.inla.probit = inla(formula=formula.inla.scaled, family="binomial",
                             data=qg.data.gg.inds,
                             control.compute=list(dic=T),
                             control.family = list(link = "probit")
)

fit.inla.logit = inla(formula=formula.inla.scaled, family="binomial",
                             data=qg.data.gg.inds,
                             control.compute=list(dic=T), 
                             control.family = list(link = "logit")
)

fit.inla.gaussian = inla(formula=formula.inla.scaled, family="gaussian",
                             data=qg.data.gg.inds,
                             control.compute=list(dic=T, cpo=T) 
)
```

## Residual analyses on Gaussian model

For the Gaussian INLA model we also compute PIT. From example (don't copy this!) "The PIT is the probability of a new response less than the observed response using a model based on the rest of the data. We'd expect the PIT values to be uniformly distributed if the model assumptions are correct." [From here](https://julianfaraway.github.io/brinla/examples/chicago.html).

The first plot obviously shows a non-linear trend but rather a sigmoid-like curve. This is interesting!

The second plot shows the fitted values as a function of PIT. Not sure how it should look like, but definately not like this!

The third plot is the posterior means of the linear predictor for the Gaussian fit versus the same value for the probit model. If we compare logit to probit we see pretty close to a one-to-one correspondance. This is completely violated when comparing the Gaussian one to the two other models.

```{r}
# Residual analysis on Gaussian INLA object:)
pit.g = fit.inla.gaussian$cpo$pit

# <Plot 1> Analogous to QQ-plot so should be linear
# --------
plot(
  (1:length(pit.g))/(length(pit.g)+1), sort(pit.g), xlab="Quantiles",
  ylab="Sorted PIT values", main="Sorted PIT values for Gaussian model"
)

# <Plot 2> Posterior mean fitted values as a function of PIT values
# --------    analagous to "Residuals vs fitted"
plot(fit.inla.gaussian$summary.fitted.values$mean, pit.g,
     xlab="Posterior mean fitted values",
     ylab="PIT values", main="Posterior mean vs. PIT values"
     )

# <Plot 3> Mean linear predictor of different models, showing 
# --------    how different predictors for the models are
par(mfrow=c(1,3))
plot(fit.inla.logit$summary.linear.predictor[, 1],
     fit.inla.probit$summary.linear.predictor[, 1],
     main="\nLogit (x) versus Probit (y)", xlab="",ylab=""
)
abline(0,1)
plot(fit.inla.gaussian$summary.linear.predictor[, 1],
     fit.inla.probit$summary.linear.predictor[, 1],
     main="\nGaussian (x) versus Probit (y)", xlab="", ylab=""
)
abline(0,1)
plot(fit.inla.gaussian$summary.linear.predictor[, 1],
     fit.inla.logit$summary.linear.predictor[, 1],
     main="\nGaussian (x) versus Probit (y)", xlab="", ylab=""
)
abline(0,1)
mtext("Mean linear predictor of the different models",
      side = 3, line = -1, outer = TRUE)

# <Plot 4> Plot of 'residuals', i.e. difference in true data and the 
# --------    50% quantile of the fitted values

# Compute residuals from the 50% quantile of fitted values
# Scale residuals by multiplying the square of the precisions? Currently: no scaling
n.obs = length(qg.data.gg.inds$u)
resids = qg.data.gg.inds$surv.ind.to.ad -
  fit.inla.gaussian$summary.fitted.values$`0.5quant`
par(mfrow=c(1,1))
plot(resids, main="Residuals of Gaussian model", ylab="")

# <Plot 5> Recreation of QQ plot using residuals computed above instead of PIT values
qqplot(qnorm(ppoints(n.obs),
             mean = mean(qg.data.gg.inds$surv.ind.to.ad),
             sd = sd(qg.data.gg.inds$surv.ind.to.ad)
             ),
       resids, xlab="Theoretical quantiles", ylab="Sample Quantiles",
       main="Q-Q plot from 'residuals' above")

```

We define a general method for looking at the results of an INLA model.

```{r}
analyze.inla.fit <- function(inla.fit){
  # Collecting diagnostic functions in this method:-)
  #' Check if there is a problem (ok of =0) and dic
  print(paste(inla.fit$mode$mode.status,
  inla.fit$dic$dic))
  
  print(summary(inla.fit))
  
  #inla.fit$summary.hyperpar,
  #inla.fit$summary.fixed,
  
  #inla_mmarginal(inla.fit),
  #inla_emarginal(inla.fit)
  #))
  
  #' Plotting the posterior marginals for the variances; This is a bit cumbersome,
  #' because INLA works with precisions, so we need a transformation. 
  #' The code below does it for us:
  par(mfrow=c(1,3))
  
  plot(inla.tmarginal(
    function(x) 1/x,inla.fit$marginals.hyperpar$`Precision for nestrec`),
    type="l",main = "next")
  
  plot(inla.tmarginal(
    function(x) 1/x,inla.fit$marginals.hyperpar$`Precision for natalyr.id`),
    type="l",main="natalyr")
  
  plot(inla.tmarginal(
    function(x) 1/x,inla.fit$marginals.hyperpar$`Precision for id`),
    type="l",main="animal")
}

# analyze.inla.fit(fit.inla.probit)

```

Below is a method used to obtain posterior distribution of the back-transformed heritability:

```{r}
get.h2 <- function(inla.fit, n, use.scale=F, model=NA){
  samples <- inla.hyperpar.sample(n=n,inla.fit)

  denominator = 1/samples[,"Precision for id"] + 1/samples[,"Precision for natalyr.id"] +
    1/samples[,"Precision for nestrec"]
  
  if(use.scale){
    # We need model specification to use scale
    stopifnot(model %in% c("binom1.probit", "binom1.logit"))
    scale.param = ifelse(model == "binom1.probit", 1, pi^2/3)
    denominator = denominator + scale.param
  }
  
  h2.inla <- (1/samples[,"Precision for id"]) / denominator
  return(h2.inla)
}

get.h2.from.qgparams <- function(inla.fit, modelname, n, n.obs=nrow(d.ped)){
  #' Computes a posterior of data-scale heritability (h2) using QGParams
  #'  
  #' Params:
  #' inlafit    the fitted INLA object
  #' modelname  a string specifying model
  #'    ("Gaussian", "binomN1.probit", "binom1.logit")
  #' n.obs      keyword argument if binomial model is has N != 1 trials
  #'    NB: Should explicitly be set to NULL if not relevant (Gaussian model)
  stopifnot(modelname %in% c("Gaussian", "binom1.probit", "binom1.logit"))
  samples.posterior <- inla.hyperpar.sample(n=n,inla.fit)
  mu = inla.fit$summary.fixed$mean[1]
  va.samples = 1/samples.posterior[,"Precision for id"]
  vp.samples = va.samples +
    1/samples.posterior[,"Precision for natalyr.id"] +
    1/samples.posterior[,"Precision for nestrec"]
  
  kwargs = list(verbose=F)
  h2.getter = function(...){get("h2.obs", suppressWarnings(QGparams(...)))}
  out = mapply(h2.getter, mu, va.samples, vp.samples, modelname, MoreArgs=kwargs)
  return(out)
}
```

We extend the contents of the INLA fit to include heritabilities on the different scales

```{r}
# Running cell
n.samples = 10000
fit.inla.gaussian$h2.latent = get.h2(fit.inla.gaussian, n.samples)
fit.inla.logit$h2.latent = get.h2(fit.inla.logit, n.samples)
fit.inla.probit$h2.latent = get.h2(fit.inla.probit, n.samples)

fit.inla.logit$h2.scaled = get.h2(fit.inla.logit, n.samples, use.scale=T,
                                  model="binom1.logit")
fit.inla.probit$h2.scaled = get.h2(fit.inla.probit, n.samples,use.scale=T,
                                   model="binom1.probit")

fit.inla.logit$h2.qgglmm  = get.h2.from.qgparams(fit.inla.logit, "binom1.logit", n.samples)
fit.inla.probit$h2.qgglmm = get.h2.from.qgparams(fit.inla.probit, "binom1.probit", n.samples)
```

Plotting some histograms:

Trying one with all overlapping:

```{r}
df.latent.h2 = data.frame(samples=c(unname(fit.inla.logit$h2.latent), unname(fit.inla.probit$h2.latent)),
                      Model=c(
                        rep("Logit",length(fit.inla.logit$h2.latent)),
                        rep("Probit",length(fit.inla.probit$h2.latent))
                      )
                        )

ggplot(df.latent.h2, aes(x=samples, fill=Model)) +
  geom_density(alpha=0.5) +
  ggtitle("Posterior of latent scale heritability for binomial INLA models") +
  xlab("(Latent-scale) Heritability") +
  ylab("Density")
```

```{r}
df.transformed.h2 = data.frame(
  samples=c(
    unname(fit.inla.logit$h2.qgglmm),
    unname(fit.inla.probit$h2.qgglmm),
    unname(fit.inla.gaussian$h2.latent)
    ),
  Model=c(
    rep("Logit",length(fit.inla.logit$h2.qgglmm)),
    rep("Probit", length(fit.inla.probit$h2.qgglmm)),
    rep("Gaussian (no transformation)",length(fit.inla.gaussian$h2.latent))
    )
  )

ggplot(df.transformed.h2, aes(x=log(samples), fill=Model)) +
  geom_density(alpha=0.5) +
  ggtitle("Posterior of transformed heritability") +
  xlab("(Latent-scale) Log-heritability") +
  ylab("Density")
```

Let's try to make table dynamic:

```{r}
get_mode <- function(vec){
  d = density(vec)
  d$x[which.max(d$y)]
}

print_one_metric <- function(fit, param, digits){
  paste(
    round(mean(get(param, fit)),digits), " (",
    round(get_mode(get(param, fit)),digits), ") \\pm ",
    round(sd(get(param,fit)),digits), sep="")
}
print_metrics <- function(fit,digits){
  out = c()
  param_names = c("h2.scaled", "h2.qgglmm")
  # Deal with latent first
  out[1] = print_one_metric(fit, "h2.latent", digits)
  for(i in 2:3){
    if('fit.inla.gaussian' != deparse(substitute(fit))){
      out[i] <- print_one_metric(fit,param_names[i-1], digits)
    }
    else{
      out[i] <- "--"
    }
  }
  return(out)
}


heritabilities = data.frame(
  logit=print_metrics(fit.inla.logit, 4),
  probit=print_metrics(fit.inla.probit, 4),
  gaussian=print_metrics(fit.inla.gaussian, 4)
  )
rownames(heritabilities) = c("Latent", "Scaled", "QGglmm")

heritabilities

```

# Simulation data

```{r}


# set a value for the Ne/Nc ratio
# here is 0.5 but it can be set to 0.15 or 0.05
NeNc <- 0.5
# set other parameters 
# (idgen = id per generations, nGen = number of generations)
idgen <- 100
nGen <- 9

# generate the pedigree using the function generatePedigree from GeneticsPed
# nFather and nMother are the number of fathers and mothers per generation
# they are generated according to the selected Ne/Nc ratio
ped0 <- generatePedigree(nId = idgen, nGeneration = nGen, 
                         nFather = idgen * NeNc, nMother = idgen * NeNc)  

# N individuals
Nid <- length(ped0$id)


# set correct format for pedigree
pedigree <- ped0[ , c(1,3,2)]
names(pedigree) <- c("id", "dam", "sire")
head(pedigree)
# generate breeding values (always constant)
# using the function rbv from MCMCglmm
# fix the additive variance value, here is 0.3 but it can be any value
Z <- diag(Nid)
sigmaA <- 0.4
# pedigree <- ped0[ ,1:3]
u <- rbv(pedigree, sigmaA) # Breeding values for each individual 

# How do we generate the rest of the data tho? Like number survived and whatnot

```

Now we try to run it through the model pipeline:

```{r}
simulated.d.ped <- pedigree
simulated.d.ped <- nadiv::prepPed(simulated.d.ped)
simulated.Cmatrix <- nadiv::makeAinv(simulated.d.ped)$Ainv # TODO might need to index here?

# assign random response, 50%-50%
simulated.d.ped$response = sample(0:1, size=nrow(simulated.d.ped), replace=T)
head(simulated.d.ped)

simulated.formula = response ~ 1 + # Intercept + a_i only
  f(id,model="generic0",
    Cmatrix=simulated.Cmatrix,     
    constr = F, # Shouldn't matter
    hyper=list(
      prec=list(initial=log(1/10), prior="pc.prec",param=c(1,0.05)) # PC priors
    ))

simulated.fit.inla = inla(formula=simulated.formula, family="binomial",
                             data=simulated.d.ped,
                             control.compute=list(dic=T),
                             control.family = list(link = "probit")
)

summary(simulated.fit.inla)
simulated.fit.inla$mode$mode.status
```
